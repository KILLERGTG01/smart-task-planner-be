package services

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"strings"
	"time"
)

type Task struct {
	Task         string   `json:"task"`
	DurationDays int      `json:"duration_days"`
	DependsOn    []string `json:"depends_on"`
}

func GeneratePlan(ctx context.Context, goal string) ([]Task, error) {
	base := strings.TrimSuffix(os.Getenv("GEMINI_BASE_URL"), "/")
	key := os.Getenv("GEMINI_API_KEY")
	if base == "" || key == "" {
		fmt.Printf("Gemini config missing - using fallback plan\n")
		return createFallbackPlan(goal), nil
	}

	payload := map[string]any{
		"contents": []map[string]any{
			{
				"parts": []map[string]any{
					{
						"text": fmt.Sprintf(`Break down this goal into actionable tasks with suggested deadlines and dependencies.: "%s"

Return ONLY a valid JSON array of tasks. Each task must have exactly these fields:
- "task": string (description of the task)
- "duration_days": number (estimated days to complete)
- "depends_on": array of strings (names of prerequisite tasks, empty array if none)

Example format:
[
  {"task": "Research topic", "duration_days": 2, "depends_on": []},
  {"task": "Create outline", "duration_days": 1, "depends_on": ["Research topic"]}
]

Goal: %s`, goal, goal),
					},
				},
			},
		},
		"generationConfig": map[string]any{
			"maxOutputTokens": 1000,
			"temperature":     0.7,
		},
	}

	body, _ := json.Marshal(payload)
	url := fmt.Sprintf("%s/v1beta/models/gemini-2.5-flash-lite:generateContent?key=%s", base, key)

	req, _ := http.NewRequestWithContext(ctx, "POST", url, bytes.NewReader(body))
	req.Header.Set("Content-Type", "application/json")

	client := &http.Client{Timeout: 60 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		fmt.Printf("Gemini API request failed: %v, using fallback plan\n", err)
		return createFallbackPlan(goal), nil
	}
	defer resp.Body.Close()

	b, _ := io.ReadAll(resp.Body)

	fmt.Printf("Gemini API Response Status: %d\n", resp.StatusCode)
	fmt.Printf("Gemini API Response Body: %s\n", string(b))

	if resp.StatusCode != http.StatusOK {
		fmt.Printf("Gemini API error: status %d, using fallback plan\n", resp.StatusCode)
		return createFallbackPlan(goal), nil
	}

	// Parse Gemini API response
	var geminiResp struct {
		Candidates []struct {
			Content struct {
				Parts []struct {
					Text string `json:"text"`
				} `json:"parts"`
			} `json:"content"`
		} `json:"candidates"`
	}

	if err := json.Unmarshal(b, &geminiResp); err != nil {
		fmt.Printf("Failed to parse Gemini response: %v, using fallback plan\n", err)
		return createFallbackPlan(goal), nil
	}

	if len(geminiResp.Candidates) == 0 || len(geminiResp.Candidates[0].Content.Parts) == 0 {
		fmt.Printf("No content generated by Gemini, using fallback plan\n")
		return createFallbackPlan(goal), nil
	}

	text := geminiResp.Candidates[0].Content.Parts[0].Text
	fmt.Printf("Generated text: %s\n", text)

	// Extract JSON array from the response
	jsonStart := strings.Index(text, "[")
	jsonEnd := strings.LastIndex(text, "]")
	if jsonStart == -1 || jsonEnd == -1 || jsonEnd <= jsonStart {
		fmt.Printf("No JSON array found in response, using fallback plan\n")
		return createFallbackPlan(goal), nil
	}

	arrText := text[jsonStart : jsonEnd+1]
	var tasks []Task
	if err := json.Unmarshal([]byte(arrText), &tasks); err != nil {
		fmt.Printf("JSON parse error: %v, using fallback plan\n", err)
		fmt.Printf("Attempted to parse: %s\n", arrText)
		return createFallbackPlan(goal), nil
	}

	// Validate tasks
	if len(tasks) == 0 {
		fmt.Printf("No tasks generated, using fallback plan\n")
		return createFallbackPlan(goal), nil
	}

	fmt.Printf("Successfully generated %d tasks\n", len(tasks))
	return tasks, nil
}

func createFallbackPlan(goal string) []Task {
	return []Task{
		{
			Task:         "Research and understand the goal: " + goal,
			DurationDays: 2,
			DependsOn:    []string{},
		},
		{
			Task:         "Create a detailed plan and timeline",
			DurationDays: 1,
			DependsOn:    []string{"Research and understand the goal: " + goal},
		},
		{
			Task:         "Execute the first phase of the plan",
			DurationDays: 5,
			DependsOn:    []string{"Create a detailed plan and timeline"},
		},
		{
			Task:         "Review progress and adjust approach",
			DurationDays: 1,
			DependsOn:    []string{"Execute the first phase of the plan"},
		},
		{
			Task:         "Complete the goal: " + goal,
			DurationDays: 7,
			DependsOn:    []string{"Review progress and adjust approach"},
		},
	}
}
